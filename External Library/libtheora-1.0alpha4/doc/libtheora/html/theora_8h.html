<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libtheora: theora.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">theora</a></div>
<h1>theora.h File Reference</h1>The libtheora C API. <a href="#_details">More...</a>
<p>
<code>#include &lt;ogg/ogg.h&gt;</code><br>

<p>
<a href="theora_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structyuv__buffer.html">yuv_buffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A YUV buffer for passing uncompressed frames to and from the codec.  <a href="structyuv__buffer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheora__info.html">theora_info</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Theora bitstream info.  <a href="structtheora__info.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheora__state.html">theora_state</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Codec internal state and context.  <a href="structtheora__state.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtheora__comment.html">theora_comment</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comment header metadata.  <a href="structtheora__comment.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0" doxytag="theora.h::OC_FAULT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a0">OC_FAULT</a>&nbsp;&nbsp;&nbsp;-1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">general failure <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1" doxytag="theora.h::OC_EINVAL"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a1">OC_EINVAL</a>&nbsp;&nbsp;&nbsp;-10</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">library encountered invalid internal data <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2" doxytag="theora.h::OC_DISABLED"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a2">OC_DISABLED</a>&nbsp;&nbsp;&nbsp;-11</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">requested action is disabled <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="theora.h::OC_BADHEADER"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a3">OC_BADHEADER</a>&nbsp;&nbsp;&nbsp;-20</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">header packet was corrupt/invalid <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="theora.h::OC_NOTFORMAT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a4">OC_NOTFORMAT</a>&nbsp;&nbsp;&nbsp;-21</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">packet is not a theora packet <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="theora.h::OC_VERSION"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a5">OC_VERSION</a>&nbsp;&nbsp;&nbsp;-22</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitstream version is not handled <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="theora.h::OC_IMPL"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a6">OC_IMPL</a>&nbsp;&nbsp;&nbsp;-23</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">feature or action not implemented <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7" doxytag="theora.h::OC_BADPACKET"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a7">OC_BADPACKET</a>&nbsp;&nbsp;&nbsp;-24</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">packet is corrupt <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8" doxytag="theora.h::OC_NEWPACKET"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a8">OC_NEWPACKET</a>&nbsp;&nbsp;&nbsp;-25</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">packet is an (ignorable) unhandled extension <br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structtheora__comment.html">theora_comment</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a9">theora_comment</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comment header metadata.  <a href="#a9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a38">theora_colorspace</a> { <a class="el" href="theora_8h.html#a38a10">OC_CS_UNSPECIFIED</a>, 
<a class="el" href="theora_8h.html#a38a11">OC_CS_ITU_REC_470M</a>, 
<a class="el" href="theora_8h.html#a38a12">OC_CS_ITU_REC_470BG</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Colorspace.  <a href="#a38">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a13">theora_version_string</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a human-readable string to identify the encoder vendor and version.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ogg_uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a14">theora_version_number</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a 32-bit version number.  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a15">theora_encode_init</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, <a class="el" href="structtheora__info.html">theora_info</a> *c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the theora encoder.  <a href="#a15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a16">theora_encode_YUVin</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t, <a class="el" href="structyuv__buffer.html">yuv_buffer</a> *yuv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit a YUV buffer to the theora encoder.  <a href="#a16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a17">theora_encode_packetout</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t, int last_p, ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request the next packet of encoded video.  <a href="#a17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a18">theora_encode_header</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t, ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a packet containing the initial header.  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a19">theora_encode_comment</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a comment header packet from provided metadata.  <a href="#a19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a20">theora_encode_tables</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t, ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a packet containing the codebook tables for the stream.  <a href="#a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a21">theora_decode_header</a> (<a class="el" href="structtheora__info.html">theora_info</a> *ci, <a class="el" href="structtheora__comment.html">theora_comment</a> *cc, ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decode an Ogg packet, with the expectation that the packet contains an initial header, comment data or codebook tables.  <a href="#a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a22">theora_decode_init</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, <a class="el" href="structtheora__info.html">theora_info</a> *c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a <a class="el" href="structtheora__state.html">theora_state</a> handle for decoding.  <a href="#a22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a23">theora_decode_packetin</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input a packet containing encoded data into the theora decoder.  <a href="#a23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a24">theora_decode_YUVout</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, <a class="el" href="structyuv__buffer.html">yuv_buffer</a> *yuv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output the next available frame of decoded YUV data.  <a href="#a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a25">theora_packet_isheader</a> (ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Report whether a theora packet is a header or not This function does no verification beyond checking the header flag bit so it should not be used for bitstream identification; use <a class="el" href="theora_8h.html#a21">theora_decode_header()</a> for that.  <a href="#a25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a26">theora_packet_iskeyframe</a> (ogg_packet *op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Report whether a theora packet is a keyframe or not.  <a href="#a26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ogg_int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a27">theora_granule_frame</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, ogg_int64_t granulepos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a granulepos to an absolute frame number.  <a href="#a27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a28">theora_granule_time</a> (<a class="el" href="structtheora__state.html">theora_state</a> *th, ogg_int64_t granulepos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert a granulepos to absolute time in seconds.  <a href="#a28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a29">theora_info_init</a> (<a class="el" href="structtheora__info.html">theora_info</a> *c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a <a class="el" href="structtheora__info.html">theora_info</a> structure.  <a href="#a29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a30">theora_info_clear</a> (<a class="el" href="structtheora__info.html">theora_info</a> *c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear a <a class="el" href="structtheora__info.html">theora_info</a> structure.  <a href="#a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a31">theora_clear</a> (<a class="el" href="structtheora__state.html">theora_state</a> *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all internal data associated with a <a class="el" href="structtheora__state.html">theora_state</a> handle.  <a href="#a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a32" doxytag="theora.h::theora_comment_init"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a32">theora_comment_init</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize an allocated <a class="el" href="structtheora__comment.html">theora_comment</a> structure. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a33">theora_comment_add</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, char *comment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a comment to an initialized <a class="el" href="structtheora__comment.html">theora_comment</a> structure.  <a href="#a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a34">theora_comment_add_tag</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, char *tag, char *value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a comment to an initialized <a class="el" href="structtheora__comment.html">theora_comment</a> structure.  <a href="#a34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a35">theora_comment_query</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, char *tag, int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">look up a comment value by tag  <a href="#a35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a36">theora_comment_query_count</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc, char *tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">look up the number of instances of a tag  <a href="#a36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a37" doxytag="theora.h::theora_comment_clear"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="theora_8h.html#a37">theora_comment_clear</a> (<a class="el" href="structtheora__comment.html">theora_comment</a> *tc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clears an allocated <a class="el" href="structtheora__comment.html">theora_comment</a> struct so that it can be freed. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The libtheora C API. 
<p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a9" doxytag="theora.h::theora_comment"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct <a class="el" href="structtheora__comment.html">theora_comment</a>  <a class="el" href="structtheora__comment.html">theora_comment</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Comment header metadata. 
<p>
This structure holds the in-stream metadata corresponding to the 'comment' header packet.<p>
Meta data is stored as a series of (tag, value) pairs, in length-encoded string vectors. The first occurence of the '=' character delimits the tag and value. A particular tag may occur more than once. The character set encoding for the strings is always utf-8, but the tag names are limited to case-insensitive ascii. See the spec for details.<p>
In filling in this structure, <a class="el" href="theora_8h.html#a21">theora_decode_header()</a> will null-terminate the user_comment strings for safety. However, the bitstream format itself treats them as 8-bit clean, and so the length array should be treated as authoritative for their length.     </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="a38" doxytag="theora.h::theora_colorspace"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="theora_8h.html#a38">theora_colorspace</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A Colorspace. 
<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="a38a10" doxytag="OC_CS_UNSPECIFIED"></a>OC_CS_UNSPECIFIED</em>&nbsp;</td><td>
the colorspace is unknown or unspecified </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a38a11" doxytag="OC_CS_ITU_REC_470M"></a>OC_CS_ITU_REC_470M</em>&nbsp;</td><td>
best option for 'NTSC' content </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a38a12" doxytag="OC_CS_ITU_REC_470BG"></a>OC_CS_ITU_REC_470BG</em>&nbsp;</td><td>
best option for 'PAL' content </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a31" doxytag="theora.h::theora_clear"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void theora_clear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>t</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free all internal data associated with a <a class="el" href="structtheora__state.html">theora_state</a> handle. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="theora.h::theora_comment_add"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void theora_comment_add           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>comment</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a comment to an initialized <a class="el" href="structtheora__comment.html">theora_comment</a> structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>comment</em>&nbsp;</td><td>must be a null-terminated string encoding the comment in "TAG=the value" form </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="theora.h::theora_comment_add_tag"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void theora_comment_add_tag           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a comment to an initialized <a class="el" href="structtheora__comment.html">theora_comment</a> structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>a null-terminated string containing the tag associated with the comment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the corresponding value as a null-terminated string Neither <a class="el" href="theora_8h.html#a33">theora_comment_add()</a> nor <a class="el" href="theora_8h.html#a34">theora_comment_add_tag()</a> support comments containing null values, although the bitstream format supports this. To add such comments you will need to manipulate the <a class="el" href="structtheora__comment.html">theora_comment</a> structure directly </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="theora.h::theora_comment_query"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">char* theora_comment_query           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>count</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
look up a comment value by tag 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tc</em>&nbsp;</td><td>an initialized <a class="el" href="structtheora__comment.html">theora_comment</a> structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>the tag to look up </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>the instance of the tag. The same tag can appear multiple times, each with a distinct and ordered value, so an index is required to retrieve them all. Use <a class="el" href="theora_8h.html#a36">theora_comment_query_count()</a> to get the legal range for the count parameter </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the queried tag's value </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NULL</em>&nbsp;</td><td>if no matching tag is found </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="theora.h::theora_comment_query_count"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_comment_query_count           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>tag</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
look up the number of instances of a tag 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tc</em>&nbsp;</td><td>an initialized <a class="el" href="structtheora__comment.html">theora_comment</a> structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>the tag to look up </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number on instances of a particular tag. Call this first when querying for a specific tag and then interate over the number of instances with separate calls to <a class="el" href="theora_8h.html#a35">theora_comment_query()</a> to retrieve all instances in order. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="theora.h::theora_decode_header"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_decode_header           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__info.html">theora_info</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ci</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>cc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Decode an Ogg packet, with the expectation that the packet contains an initial header, comment data or codebook tables. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ci</em>&nbsp;</td><td>A <a class="el" href="structtheora__info.html">theora_info</a> structure to fill. This must have been previously initialized with <a class="el" href="theora_8h.html#a29">theora_info_init()</a>. If <em>op</em> contains an initial header, <a class="el" href="theora_8h.html#a21">theora_decode_header()</a> will fill <em>ci</em> with the parsed header values. If <em>op</em> contains codebook tables, <a class="el" href="theora_8h.html#a21">theora_decode_header()</a> will parse these and attach an internal representation to <em>ci-&gt;codec_setup</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cc</em>&nbsp;</td><td>A <a class="el" href="structtheora__comment.html">theora_comment</a> structure to fill. If <em>op</em> contains comment data, <a class="el" href="theora_8h.html#a21">theora_decode_header()</a> will fill <em>cc</em> with the parsed comments. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet structure which you expect contains an initial header, comment data or codebook tables.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OC_BADHEADER</em>&nbsp;</td><td><em>op</em> is NULL; OR the first byte of <em>op-&gt;packet</em> has the signature of an initial packet, but op is not a b_o_s packet; OR this packet has the signature of an initial header packet, but an initial header packet has already been seen; OR this packet has the signature of a comment packet, but the initial header has not yet been seen; OR this packet has the signature of a comment packet, but contains invalid data; OR this packet has the signature of codebook tables, but the initial header or comments have not yet been seen; OR this packet has the signature of codebook tables, but contains invalid data; OR the stream being decoded has a compatible version but this packet does not have the signature of a theora initial header, comments, or codebook packet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OC_VERSION</em>&nbsp;</td><td>The packet data of <em>op</em> is an initial header with a version which is incompatible with this version of libtheora. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OC_NEWPACKET</em>&nbsp;</td><td>the stream being decoded has an incompatible (future) version and contains an unknown signature. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The normal usage is that <a class="el" href="theora_8h.html#a21">theora_decode_header()</a> be called on the first three packets of a theora logical bitstream in succession. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="theora.h::theora_decode_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_decode_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structtheora__info.html">theora_info</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>c</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a <a class="el" href="structtheora__state.html">theora_state</a> handle for decoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>The <a class="el" href="structtheora__state.html">theora_state</a> handle to initialize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>A <a class="el" href="structtheora__info.html">theora_info</a> struct filled with the desired decoding parameters. This is of course usually obtained from a previous call to <a class="el" href="theora_8h.html#a21">theora_decode_header()</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 Success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="theora.h::theora_decode_packetin"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_decode_packetin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Input a packet containing encoded data into the theora decoder. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle previously initialized for decoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet containing encoded theora data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OC_BADPACKET</em>&nbsp;</td><td><em>op</em> does not contain encoded video data </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="theora.h::theora_decode_YUVout"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_decode_YUVout           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structyuv__buffer.html">yuv_buffer</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>yuv</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Output the next available frame of decoded YUV data. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle previously initialized for decoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yuv</em>&nbsp;</td><td>A <a class="el" href="structyuv__buffer.html">yuv_buffer</a> in which libtheora should place the decoded data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="theora.h::theora_encode_comment"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_encode_comment           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__comment.html">theora_comment</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>tc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request a comment header packet from provided metadata. 
<p>
A pointer to the comment data is placed in a user-provided ogg_packet structure. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tc</em>&nbsp;</td><td>A <a class="el" href="structtheora__comment.html">theora_comment</a> structure filled with the desired metadata </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet structure to fill. libtheora will set all elements of this structure, including a pointer to the encoded comment data. The memory for the comment data is owned by libtheora. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="theora.h::theora_encode_header"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_encode_header           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request a packet containing the initial header. 
<p>
A pointer to the header data is placed in a user-provided ogg_packet structure. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle previously initialized for encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet structure to fill. libtheora will set all elements of this structure, including a pointer to the header data. The memory for the header data is owned by libtheora. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="theora.h::theora_encode_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_encode_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structtheora__info.html">theora_info</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>c</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize the theora encoder. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>The <a class="el" href="structtheora__state.html">theora_state</a> handle to initialize for encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ti</em>&nbsp;</td><td>A <a class="el" href="structtheora__info.html">theora_info</a> struct filled with the desired encoding parameters. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 Success </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="theora.h::theora_encode_packetout"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_encode_packetout           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>last_p</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request the next packet of encoded video. 
<p>
The encoded data is placed in a user-provided ogg_packet structure. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle previously initialized for encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last_p</em>&nbsp;</td><td>whether this is the last packet the encoder should produce. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet structure to fill. libtheora will set all elements of this structure, including a pointer to encoded data. The memory for the encoded data is owned by libtheora. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>No internal storage exists OR no packet is ready </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>The encoding process has completed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="theora.h::theora_encode_tables"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_encode_tables           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_packet *&nbsp;</td>
          <td class="mdname" nowrap> <em>op</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Request a packet containing the codebook tables for the stream. 
<p>
A pointer to the codebook data is placed in a user-provided ogg_packet structure. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle previously initialized for encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet structure to fill. libtheora will set all elements of this structure, including a pointer to the codebook data. The memory for the header data is owned by libtheora. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="theora.h::theora_encode_YUVin"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_encode_YUVin           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structyuv__buffer.html">yuv_buffer</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>yuv</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Submit a YUV buffer to the theora encoder. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>A <a class="el" href="structtheora__state.html">theora_state</a> handle previously initialized for encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yuv</em>&nbsp;</td><td>A buffer of YUV data to encode. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OC_EINVAL</em>&nbsp;</td><td>Encoder is not ready, or is finished. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>The size of the given frame differs from those previously input </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>Success </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="theora.h::theora_granule_frame"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">ogg_int64_t theora_granule_frame           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_int64_t&nbsp;</td>
          <td class="mdname" nowrap> <em>granulepos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert a granulepos to an absolute frame number. 
<p>
The granulepos is interpreted in the context of a given <a class="el" href="structtheora__state.html">theora_state</a> handle.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>A previously initialized <a class="el" href="structtheora__state.html">theora_state</a> handle (encode or decode) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>granulepos</em>&nbsp;</td><td>The granulepos to convert. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The frame number corresponding to <em>granulepos</em>. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>The given granulepos is invalid (ie. negative)</td></tr>
  </table>
</dl>
Thus function was added in the 1.0alpha4 release.     </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="theora.h::theora_granule_time"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double theora_granule_time           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__state.html">theora_state</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ogg_int64_t&nbsp;</td>
          <td class="mdname" nowrap> <em>granulepos</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Convert a granulepos to absolute time in seconds. 
<p>
The granulepos is interpreted in the context of a given <a class="el" href="structtheora__state.html">theora_state</a> handle. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>A previously initialized <a class="el" href="structtheora__state.html">theora_state</a> handle (encode or decode) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>granulepos</em>&nbsp;</td><td>The granulepos to convert. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The absolute time in seconds corresponding to <em>granulepos</em>. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>The given granulepos is invalid (ie. negative) </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="theora.h::theora_info_clear"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void theora_info_clear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__info.html">theora_info</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>c</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear a <a class="el" href="structtheora__info.html">theora_info</a> structure. 
<p>
All values within the given <a class="el" href="structtheora__info.html">theora_info</a> structure are cleared, and associated internal codec setup data is freed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>A <a class="el" href="structtheora__info.html">theora_info</a> struct to initialize. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="theora.h::theora_info_init"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void theora_info_init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structtheora__info.html">theora_info</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>c</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize a <a class="el" href="structtheora__info.html">theora_info</a> structure. 
<p>
All values within the given <a class="el" href="structtheora__info.html">theora_info</a> structure are initialized, and space is allocated within libtheora for internal codec setup data. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>A <a class="el" href="structtheora__info.html">theora_info</a> struct to initialize. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="theora.h::theora_packet_isheader"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_packet_isheader           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ogg_packet *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>op</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Report whether a theora packet is a header or not This function does no verification beyond checking the header flag bit so it should not be used for bitstream identification; use <a class="el" href="theora_8h.html#a21">theora_decode_header()</a> for that. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet containing encoded theora data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>The packet is a header packet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>The packet is not a header packet (and so contains frame data)</td></tr>
  </table>
</dl>
Thus function was added in the 1.0alpha4 release.     </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="theora.h::theora_packet_iskeyframe"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int theora_packet_iskeyframe           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ogg_packet *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>op</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Report whether a theora packet is a keyframe or not. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>An ogg_packet containing encoded theora data. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>The packet contains a keyframe image </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>The packet is contains an interframe delta </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>the packet is not an image data packet at all</td></tr>
  </table>
</dl>
Thus function was added in the 1.0alpha4 release.     </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="theora.h::theora_version_number"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">ogg_uint32_t theora_version_number           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve a 32-bit version number. 
<p>
This number is composed of a 16-bit major version, 8-bit minor version and 8 bit sub-version, composed as follows: <pre>
   (VERSION_MAJOR&lt;&lt;16) + (VERSION_MINOR&lt;&lt;8) + (VERSION_SUB)
</pre> <dl compact><dt><b>Returns:</b></dt><dd>the version number. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="theora.h::theora_version_string"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const char* theora_version_string           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve a human-readable string to identify the encoder vendor and version. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>a version string. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Wed Dec 15 12:06:33 2004 for libtheora by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
